package routes

import (
	"encoding/json"
	"fmt"
	"github.com/mousybusiness/waracle-test/internal/dao"
	"github.com/mousybusiness/waracle-test/internal/db"
	"github.com/mousybusiness/waracle-test/internal/handler/middleware"
	docs "github.com/mousybusiness/waracle-test/internal/handler/swagger" // docs is generated by Swag CLI, you have to import it.
	"io"
	"log"
	"net/http"
	"strconv"
)

func BuildRoutes(database db.Database) http.Handler {
	docs.SwaggerInfo.Title = "Waracle API"
	docs.SwaggerInfo.Description = "Waracles fantastic bakery."
	docs.SwaggerInfo.Version = "1.0"
	docs.SwaggerInfo.Host = "waracle.com"
	docs.SwaggerInfo.BasePath = "/v1"
	docs.SwaggerInfo.Schemes = []string{"https"}

	router := http.NewServeMux()

	router.HandleFunc("GET /", HealthCheck)

	router.HandleFunc("GET /swagger", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(docs.SwaggerInfo.ReadDoc()))
	})

	// Users should be able to fetch a cake by ID.
	router.HandleFunc("GET /cake/{id}/", GetCake(database))

	// Users should be able to list all cakes.
	router.HandleFunc("GET /cakes/", ListCakes(database))

	// Users should be able to search for a cake by yumFactor and/or name.
	router.HandleFunc("POST /cakes/search/", SearchCakes(database))

	// Users should be able to add another cake.
	router.HandleFunc("PUT /cake/", CreateCake(database))

	// Users should be able to delete an existing cake.
	router.HandleFunc("DELETE /cake/{id}/", DeleteCake(database))

	// Add route versioning
	v1 := http.NewServeMux()
	v1.Handle("/v1/", http.StripPrefix("/v1", router))

	// Apply middlewares
	middlewares := middleware.Create(
		middleware.Logging,
		middleware.IsAuthenticated,
	)

	return middlewares(v1)
}

// HealthCheck
//
//	@Summary		Check server live
//	@Success		200		{string}	string			"OK"
//	@Router			/v1/ [get]
func HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte("OK"))
}

// GetCake
//
//	@Summary		Get cake by ID
//	@Success		200		{object}	dao.Cake
//	@Router			/v1/cake/{id} [get]
func GetCake(database db.Database) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		id := r.PathValue("id")
		atoi, err := strconv.Atoi(id)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("require int id"))
			return
		}
		cake, err := dao.GetCake(r.Context(), database, atoi)
		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusNoContent)
			return
		}

		b, err := json.Marshal(cake)
		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
		if _, err := w.Write(b); err != nil {
			log.Println(err)
			return
		}
	}
}

// ListCakes
//
//	@Summary		List all cakes
//	@Success		200		{object}	[]dao.Cake
//	@Router			/v1/cakes [get]
func ListCakes(database db.Database) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		cakes, err := dao.ListCakes(r.Context(), database)
		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		fmt.Println(cakes)

		if len(cakes) == 0 {
			w.WriteHeader(http.StatusNoContent)
			return
		}

		b, err := json.Marshal(cakes)
		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		if _, err := w.Write(b); err != nil {
			log.Println(err)
			return
		}
	}
}

// SearchCakes
//
//	@Summary		Search cakes by name and yum-factor
//	@Success		200		{object}	[]dao.Cake
//	@Router			/v1/cakes [post]
func SearchCakes(database db.Database) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		b, err := io.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("invalid body"))
			return
		}

		var request dao.SearchRequest
		if err := json.Unmarshal(b, &request); err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("invalid cake"))
			return
		}

		if request.Name == nil && request.YumFactor == nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("require name or yum_factor"))
			return
		}

		cakes, err := dao.SearchCakes(r.Context(), database, request)
		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusNoContent) // TODO check error types
			return
		}

		fmt.Println(cakes)

		if len(cakes) == 0 {
			w.WriteHeader(http.StatusNoContent)
			return
		}

		b, err = json.Marshal(cakes)
		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		if _, err := w.Write(b); err != nil {
			log.Println(err)
			return
		}
	}
}

// CreateCake
//
//	@Summary		Create a new cake
//	@Success		200		{string}	string	"created"
//	@Router			/v1/cake [put]
func CreateCake(database db.Database) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		b, err := io.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("require body"))
			return
		}

		var cake dao.Cake
		if err := json.Unmarshal(b, &cake); err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("invalid cake"))
			return
		}

		if err := cake.Validate(); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		if err := dao.CreateCake(r.Context(), database, &cake); err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("created"))
	}
}

// DeleteCake
//
//	@Summary		Delete cake by ID
//	@Success		200		{object}	string	"deleted"
//	@Router			/v1/cake [put]
func DeleteCake(database db.Database) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		id := r.PathValue("id")
		atoi, err := strconv.Atoi(id)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("require int id"))
			return
		}
		if err := dao.DeleteCake(r.Context(), database, atoi); err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("deleted"))
	}
}
